<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <title></title>
</head>
<body>
    <a href="#IntegrationWithVS">Jump to Integration with Visual Studio.</a>
    <h2>
        Introduction</h2>
    <p>
        For most developers Visual Studio is the best tool for the job. And due to variety
        of factors it is also often the only one. It comes with plethora of project templates
        to get a developer started or to aid to a seasoned professional. Regrettably, the
        templates are often oversimplified samples that end up in the real products for
        the mere fact that they were the default, not because they suited for the problem
        at hand.
    </p>
    <p>
        This article details how to implement a web service but with a better project structure,
        reduced coupling between components and separation between interface definition
        and their implementation. And last but not least, a new template is provided to
        fossilize these newly found principals.
    </p>
    <h2>
        Background</h2>
    <p>
        For illustration purposes the article is structured around a phantom web service
        built atop of WCF. The service exposes a collection of resources through REST, which
        in turn can be hosted in IIS or stand alone. Also sample web client application
        is included, as well as unit test for the core logic.</p>
    <p>
        The notion of separating software projects into layers has been around for a while,
        but still there seems to be a lot confusion on terminology and techniques. Particularly,
        such discussion(s) often intermix tier separation and software layers, hence an
        introductory article <a href="http://msdn.microsoft.com/en-us/library/aa905336.aspx">
            "Pragmatic Architecture: Layering" by Ted Neward</a> is recommended.
    </p>
    <h2>
        Web service -- the 'REST Technobabble'</h2>
    <p>
        Software development is filled with new technology and new terminology often for
        the same or even older technology, but in any case there is plenty of technobabble
        involved. And in case of this article the web service actually manages a collection
        of REST technobabble phrases. A client of this web service can request a list of
        [latest] technobabble phrases, add new ones, modify existing and etc (i.e. CRUD
        support).
    </p>
    <h2>
        Projects</h2>
    <table>
        <tr>
            <td>
                <img src="RESTTechnobabble/projects.PNG" alt="Projects" />
            </td>
            <td style="vertical-align: top">
                <p>
                    For starters, lets review the projects involved and the way they are organized in
                    the Visual Studio solution. Next to this paragraph is a snapshot of <span class="term">
                        Solution Explorer</span>, which shows several solution folders and corresponding
                    projects. The solution folders correspond to layers, which are described later.
                </p>
                <p>
                    Key points about solution folders and projects:
                    <ul>
                        <li>Solution folders are prefixed with two digit number (ex. 10, 20) for ordering purposes.</li>
                        <li>Project compilation is (still) controlled by project dependencies settings.</li>
                        <li>Project/layer dependencies is visually conveyed to the developer, i.e.: </li>
                        <li>Projects at the top depend on lower [layer] projects</li>
                    </ul>
                </p>
            </td>
        </tr>
    </table>
    <h2>
        Layers</h2>
    <table>
        <tr>
            <td>
                <img src="RESTTechnobabble/layers.PNG" alt="Layers" style="width: 423px" />
            </td>
            <td style="vertical-align: top">
                <p>
                    The diagram next to this paragraph shows the web service, its contract, hosting
                    and client(s) are allocated to different layers. Arrows on the diagram show <strong>
                        compile time</strong> dependencies between the different layers.
                </p>
                <p>
                    Layer descriptions:</p>
                <ul>
                    <li>Data Layer -- abstraction of the persistent storage*.</li>
                    <li>Core -- the core logic of the implementation</li>
                    <li>Web Services -- wrapper around the <span class="term">Core</span></li>
                    <li>Host -- hosting of the web service (i.e. IIS hosting or stand alone)</li>
                    <li>Client -- the client application(s)</li>
                </ul>
                *Note: To limit the scope of this web service project information is stored in memory
                and the corresponding logic is not factored out into separate data layer.
                <p>
                    Key points on the diagram for the layers and their dependencies:
                </p>
                <ul>
                    <li>Compile time dependencies are shown as arrows.</li>
                    <li>Higher layers depend on lower layers (and not vice versa).</li>
                    <li>Client layer depends only on the contracts and not on the implementation layers.</li>
                </ul>
            </td>
        </tr>
    </table>
    <h2>
        Assemblies</h2>
    <table>
        <tr>
            <td>
                <img src="RESTTechnobabble/assemblies.PNG" alt="Assemblies" style="width: 419px" />
            </td>
            <td style="vertical-align: top">
                <p>
                    The next diagram shows dependencies for the assemblies produced by the above projects.
                    The diagram is produced by Visual Studio and provides another confirmation the layer
                    dependencies have been observed. An interesting feature is that Visual Studio can
                    also check these dependencies against the one specified in layer diagram (above)
                    and inform when incorrect dependency has been added.
                </p>
                <p>
                    The key points on the diagram are:</p>
                <ul>
                    <li>Client side assemblies depend only on the definition of the contracts</li>
                    <li>Number of assemblies deployed on the client is smaller (hence smaller deployment
                        size)</li>
                    <li>Corrections in service implementation can be implemented without redeployment of
                        the client assemblies.</li>
                </ul>
            </td>
        </tr>
    </table>
    <h2>
        Running the sample</h2>
    <p>
        Now that you've read a lot of technobabble from previous section, it may be interesting
        to see what the running web service looks like.
    </p>
    <p>
        For the demo purpose I implemented the client to the web service as (another) web
        application that consumes and allows to manipulate the technobabble phrases (after
        all, technobabble is always evolving).</p>
    <p>
        All projects have corresponding dependencies setup and hence <strong>Build&Run of Client.WebApp</strong>
        project shall be sufficient. Otherwise you can Build&Run the Host.WebApp project
        followed by (Build&Run) of the Client.WebApp project.</p>
    <table>
        <tr>
            <td>
                <img src="RESTTechnobabble/webclient.PNG" alt="REST Technobabble web client snapshot"
                    style="height: 379px" />
            </td>
        </tr>
        <tr>
            <td>
                <img src="RESTTechnobabble/restapi.PNG" alt="REST api snapshot" style="height: 383px" />
            </td>
        </tr>
    </table>
    <h2>
        Benefits</h2>
    <p>
        Most obvious difference when compared to Visual Studio default WCF/REST template
        and the one shown here is the number of projects involved. But is it actually better?</p>
    <p>
        Well, the answer is the venerable : "It depends", but here are some beneficial aspects
        of this approach:
    </p>
    <ul>
        <li>Separation of concerns -- each project is focused on smaller more specific task</li>
        <li>Client side assemblies depend only on the definition of the contracts and hence
            no implementation assemblies need to be deployed to the client side. </li>
        <li>Number of assemblies deployed on a client is reduced (hence smaller deployment size)</li>
        <li>Corrections in service implementation can be implemented without redeployment of
            the client assemblies.</li>
        <li>Much easier implementation of unit test(s) for the functionality in the <span
            class="term">Core layer</span>.</li>
        <li>Easier to address different API semantics (ex. stateless aspect of REST vs. stateful
            usage on internal API exposed by <span class="term">Core layer</span>)</li>
        <li>Web and Host projects can focus on their targets which are very technology specifics
            and rapidly change over time. </li>
    </ul>
    All of the above seem more then fair benefit to have more granular projects.
    <h2>
        Unit test</h2>
    <p>
        As mentioned above the <span class="term">Core layer</span> can follow much simpler
        development practices. Because, it has limited dependency on the deployment infrastructure
        the unit test for it can be implemented much easier. Especially, when compared to
        the system/integration level testing required when Client and Web services are involved.</p>
    <img src="RESTTechnobabble/unittest.PNG" alt="Unit test results" />
    <p>
        Additionally, the Web and Host projects can focus on their targets which are very
        technology specifics and rapidly change over time. Today the services are implemented
        with WCF and hosted in IIS through a ASP.NET project or a standalone executable,
        tomorrow it could be a Windows(r) service or yet something else.</p>
    <h2>
        Points of interest</h2>
    <p>
        Even in this simple example this separation allows to address the difference in
        semantics much easier. For example the service is exposed through REST and implemented
        though .NET WebGet attribute. This adds the restriction that only string parameters
        will be parsed from the URI (behavior of WebGet implementation) and that consecutive
        identical calls to delete a resource is not an error condition (which it is in general
        procedural programming).
    </p>
    <h2 id="IntegrationWithVS">
        Integration with Visual Studio</h2>
    <p>
        And in conclusion to the best part: all of the above can be reasonably reused though
        a new Visual Studio template. To install the template you can navigate to <a href="http://visualstudiogallery.msdn.microsoft.com/en-us/e6c5626e-bb2f-4b6c-81a4-630a38a01489">
            Visual Studio Gallery</a> or even simpler use Visual Studio itself to install
        it:
        <ol>
            <li>Open new project dialog in Visual Studio</li>
            <li>Type in the search term: "structured"</li>
            <li>Select the "Structured WCF REST Service" item, and proceed with the wizard.</li>
        </ol>
        If everything works you should see a dialog a the one shown below</p>
    <img width="600px" src="RESTTechnobabble/vsinstall.PNG" alt="Visual studio install" />
    <h2>
        References</h2>
    <p>
        Volumes of information regarding application/presentation split and the corresponding
        presentation/business logic/data access tiers are available -- in fact to may to
        list here. Nevertheless, practical advise is rare. Following references where used
        for this article:
        <ul>
            <li><a href="http://msdn.microsoft.com/en-us/library/aa905336.aspx">"Pragmatic Architecture:
                Layering" by Ted Neward</a></li>
            <li><a href="http://perseus.franklins.net/dnrtvplayer/player.aspx?ShowNum=0122">Video
                cast with Miguel Castro.</a> -- Reinforced my views on project organization and
                gives that hope separation of concerns will be evangelized along side with .NET
                technologies.</li>
            <li><a href="http://www.wordle.net/">Wordle</a> was used to generate the technobabble
                logo.</li>
        </ul>
</body>
</html>
